% ---
% Title: Event-Driven MATLAB Backtester for SMA, RSI, and YOLOv8
% Author: Gemini
% Date: 14-Nov-2025
%
% Description:
% This script provides an event-driven backtesting framework in MATLAB.
% It is designed to test a trading strategy that combines signals from:
% 1. Simple Moving Average (SMA) Crossover (Vectorized)
% 2. Relative Strength Index (RSI) (Vectorized)
% 3. A live pattern-detection model (YOLOv8) processed in the loop.
%
% This script uses built-in MATLAB data for demonstration purposes.
%
% Disclaimer: FOR EDUCATIONAL PURPOSES ONLY. NOT FINANCIAL ADVICE.
% ---

%% 1. Setup Environment
clear;         % Clear workspace
clc;           % Clear command window
close all;     % Close all figures

%% 2. Load and Prepare Data
% We will use a built-in dataset (Dow Jones Industrial) to make this
% script runnable for anyone.
% You can replace this section with your own data loader (e.g., readtable).

try
    % Load sample 'Data_GlobalIdx.mat' which contains 'dates' and 'ind'
    load('Data_GlobalIdx.mat');
    
    % Convert date numbers to datetime objects
    priceDates = datetime(dates, 'ConvertFrom', 'datenum');
    
    % The data has 5 columns: [Open, High, Low, Close, Volume]
    % We need all of ind(:, 1:4) for the candle plot
    ohlc_data = ind(:, 1:4); % Open, High, Low, Close
    prices = ohlc_data(:, 4); % Close prices
    
    % Clean data: Remove any NaN rows from ohlc data, prices, and dates
    nanRows = any(isnan(ohlc_data), 2) | isnan(prices); % Check for NaNs
    prices = prices(~nanRows);
    ohlc_data = ohlc_data(~nanRows, :); % Keep the full, clean OHLC data
    priceDates = priceDates(~nanRows);
    
    fprintf('Loaded and prepared %d data points.\n', length(prices));
catch
    warning('Could not load sample data. Generating synthetic data.');
    prices = 100 + cumsum(randn(1000, 1) * 0.5) + sin((1:1000)'/50) * 5;
    priceDates = datetime('2020-01-01') + caldays(0:999);
    % Generate dummy OHLC data for the catch block
    ohlc_data = [prices, prices + randn(1000,1), prices - randn(1000,1), prices];
    % Ensure O,H,L,C logic (H >= O,C and L <= O,C)
    ohlc_data(:,2) = max(ohlc_data(:,1), ohlc_data(:,4)); % High
    ohlc_data(:,3) = min(ohlc_data(:,1), ohlc_data(:,4)); % Low
end

%% 3. Define Strategy Parameters
% --- Indicator Parameters ---
strat.smaFastPeriod = 50;        % Fast SMA window
strat.smaSlowPeriod = 200;       % Slow SMA window
strat.rsiPeriod     = 14;        % RSI lookback period
strat.rsiOverbought = 70;        % RSI overbought threshold
strat.rsiOversold   = 30;        % RSI oversold threshold

% --- YOLO Model Parameters ---
strat.yoloChartWindow = 100;     % e.g., use 100 bars to generate the chart
strat.yoloConfidence  = 0.80;    % Minimum confidence to trust a pattern
strat.yoloImgSize     = [640 640]; % Input size for the YOLO model

%% 3.5 Load Deep Learning Model
fprintf('Loading YOLOv8 model...\n');
% ---
% IMPORTANT:
% 1. Generate the .onnx file using the 'convert_to_onnx.py' script.
% 2. Install the "Deep Learning Toolbox Interface for YOLO v8" Add-On.
%    (Home Tab -> Add-Ons -> Get Add-Ons -> Search "YOLO v8")
% ---
modelFile = 'model.onnx'; % <-- Name generated by Python script
modelLoaded = false;
if ~isfile(modelFile)
    warning('YOLOv8 model file not found: %s', modelFile);
    warning("Please run the 'convert_to_onnx.py' script to generate it.");
else
    try
        % This function loads the ONNX file and creates a detector object
        yoloDetector = yolov8("Model", modelFile);
        modelLoaded = true;
        fprintf('YOLOv8 detector loaded successfully.\n');
    catch ME
        warning('Could not load YOLOv8 detector.');
        disp('Please ensure you have:');
        disp('1. Deep Learning Toolbox');
        disp('2. Deep Learning Toolbox Interface for YOLO v8 (Add-On)');
        disp('3. The .onnx file in the correct path.');
        disp('Error details:');
        disp(ME.message);
    end
end


%% 4. Calculate Technical Indicators (Vectorized)
% We pre-calculate the indicators that can be vectorized for speed.
fprintf('Calculating technical indicators...\n');
try
    % Calculate Fast and Slow SMAs
    smaFast = movavg(prices, 'simple', strat.smaFastPeriod);
    smaSlow = movavg(prices, 'simple', strat.smaSlowPeriod);
    
    % Calculate RSI
    rsi = rsindex(prices, strat.rsiPeriod);
catch
    error('Financial Toolbox not found. Cannot calculate movavg or rsindex.');
end

%% 5. Generate Vectorized Signals
% We generate the signals for the vectorized indicators.
% The pattern detection signal will be generated in the loop.

% --- Initialize signal vectors ---
numPoints = length(prices);
smaBuySignal    = zeros(numPoints, 1);
smaSellSignal   = zeros(numPoints, 1);
rsiBuySignal    = zeros(numPoints, 1);
rsiSellSignal   = zeros(numPoints, 1);

% --- [FIX] Create lagged vectors to replace 'lag' function ---
% This removes the dependency on the Econometrics Toolbox
smaFast_lag = [NaN; smaFast(1:end-1)];
smaSlow_lag = [NaN; smaSlow(1:end-1)];
rsi_lag     = [NaN; rsi(1:end-1)];

% --- SMA Crossover Signals ---
sma_cross_up = (smaFast > smaSlow) & (smaFast_lag <= smaSlow_lag);
sma_cross_down = (smaFast < smaSlow) & (smaFast_lag >= smaSlow_lag);
smaBuySignal(sma_cross_up) = 1;   % Golden Cross
smaSellSignal(sma_cross_down) = 1; % Death Cross

% --- RSI Signals ---
rsi_cross_up = (rsi < strat.rsiOversold) & (rsi_lag >= strat.rsiOversold);
rsi_cross_down = (rsi > strat.rsiOverbought) & (rsi_lag <= strat.rsiOverbought);
rsiBuySignal(rsi_cross_up) = 1;   % Entering oversold (buy signal)
rsiSellSignal(rsi_cross_down) = 1; % Entering overbought (sell signal)


%% 6. Run the Backtest (Event Loop)
% This is the main loop where event-driven logic (YOLO) happens.
fprintf('Running backtest...\n');

% --- Pre-allocate vectors for performance ---
position = 0; % 0 = flat, 1 = long
positions = zeros(numPoints, 1); % Stores position for each day
initialCapital = 10000;
numTrades = 0;
yoloErrors = 0; % To count YOLO errors

% We must start from 2, as 'lag' calculations make day 1 unusable
% (Our manual lag vectors with NaN handle this)
for i = 2:numPoints
    
    % --- Initialize daily signals ---
    patternBuy = 0;
    patternSell = 0;

    % --- [CRITICAL] YOLOv8 Pattern Detection (Live in loop) ---
    if modelLoaded && (i >= strat.yoloChartWindow)
        try
            % a. Get data for the chart (O, H, L, C)
            windowData = ohlc_data(i - strat.yoloChartWindow + 1 : i, :);
            
            % b. Generate the chart image (in memory)
            f = figure('Visible', 'off', 'Units', 'pixels', 'Position', [0 0 strat.yoloImgSize]);
            ax = gca; % Get current axes
            
            % candle(C, H, L, O) -
            % Our data is ohlc_data = [O, H, L, C] -> [1, 2, 3, 4]
            candle(windowData(:,4), windowData(:,2), windowData(:,3), windowData(:,1));
            
            % c. Clean the image (remove axes, labels, padding)
            axis off;
            set(ax, 'LooseInset', get(ax, 'TightInset')); % Remove all padding
            
            % d. Grab the frame
            frame = getframe(ax);
            img = frame.cdata;
            close(f); % Close the hidden figure
            
            % e. Resize image (if figure size wasn't exact)
            if size(img, 1) ~= strat.yoloImgSize(1) || size(img, 2) ~= strat.yoloImgSize(2)
                 img = imresize(img, strat.yoloImgSize);
            end

            % f. Run detection
            % We use a low threshold to catch all potential patterns
            [bboxes, scores, labels] = detect(yoloDetector, img, 'ConfidenceThreshold', 0.1);
            
            % g. Parse results and set signals
            for j = 1:length(labels)
                if scores(j) >= strat.yoloConfidence
                    % Note: Check the exact class names from your model
                    % (e.g., "bullish_pattern" or "Bullish" or "head_and_shoulders")
                    if labels(j) == "bullish_pattern" 
                        patternBuy = 1;
                    elseif labels(j) == "bearish_pattern"
                        patternSell = 1;
                    end
                end
            end
            
            % Optional: Display progress
            % if mod(i, 100) == 0
            %    fprintf('YOLO processed day %d\n', i);
            % end
            
        catch ME_yolo
            % Don't stop the backtest, just log the error and disable
            yoloErrors = yoloErrors + 1;
            if yoloErrors < 5 % Only warn a few times
                warning('YOLO detection failed at day %d: %s', i, ME_yolo.message);
            elseif yoloErrors == 5
                warning('Disabling further YOLO detection due to repeated errors.');
                modelLoaded = false; % Disable for rest of backtest
            end
        end
    end
    % --- End of YOLO Logic ---

    
    % --- [NEW] Combine Signals *Inside the Loop* ---
    % This is your "secret sauce".
    finalBuy = smaBuySignal(i) | rsiBuySignal(i) | patternBuy;
    finalSell = smaSellSignal(i) | rsiSellSignal(i) | patternSell;

    % Ensure we don't buy and sell on the same bar
    if finalBuy && finalSell
        finalBuy = 0;
        finalSell = 0;
    end
    
    % --- Check for Exit (Sell) Signal ---
    if position == 1 % We are currently in a long position
        if finalSell == 1
            % Sell! (Go flat)
            position = 0;
            numTrades = numTrades + 1;
        end
        
    % --- Check for Entry (Buy) Signal ---
    elseif position == 0 % We are currently flat
        if finalBuy == 1
            % Buy! (Go long)
            position = 1;
            numTrades = numTrades + 1;
        end
    end
    
    % Store the position for this day (for performance calculation)
    positions(i) = position;
    
end

% --- [FIX] Shift positions by 1 day (replaces lag) ---
% Our position at the end of day 'i' (positions(i)) determines the
% return we get for day 'i+1'.
positions_lagged = [0; positions(1:end-1)];


%% 7. Calculate Performance
fprintf('Calculating performance metrics...\n');

% --- [FIX] Calculate daily returns (replaces lag) ---
prices_lagged = [NaN; prices(1:end-1)];
dailyReturns_BH = (prices - prices_lagged) ./ prices_lagged;
dailyReturns_BH(1) = 0; % First day return is 0
dailyReturns_BH(isnan(dailyReturns_BH)) = 0;

% Calculate strategy returns (only earn returns when in position)
strategyReturns = positions_lagged .* dailyReturns_BH;
strategyReturns(isnan(strategyReturns)) = 0;

% Calculate cumulative returns
cumReturns_BH = cumprod(1 + dailyReturns_BH) - 1;
cumReturns_Strategy = cumprod(1 + strategyReturns) - 1;

% --- [NEW] Calculate Advanced Metrics ---
numDays = length(prices);
tradingDaysPerYear = 252; % Assume 252 trading days

% Total Return
totalReturn_BH = cumReturns_BH(end);
totalReturn_Strategy = cumReturns_Strategy(end);

% Annualized Volatility
volatility_BH = std(dailyReturns_BH) * sqrt(tradingDaysPerYear);
volatility_Strategy = std(strategyReturns) * sqrt(tradingDaysPerYear);

% Annualized Sharpe Ratio (Risk-Free Rate = 0)
% Handle case where volatility is 0 (no trades/no returns)
mean_return_BH = mean(dailyReturns_BH);
mean_return_Strategy = mean(strategyReturns);

if volatility_BH == 0
    sharpe_BH = 0;
else
    sharpe_BH = (mean_return_BH * tradingDaysPerYear) / volatility_BH;
end

if volatility_Strategy == 0
    sharpe_Strategy = 0;
else
    sharpe_Strategy = (mean_return_Strategy * tradingDaysPerYear) / volatility_Strategy;
end


% Max Drawdown
equity_curve = (1 + cumReturns_Strategy);
high_water_mark = ones(numDays, 1);
drawdown = zeros(numDays, 1);
for t = 2:numDays
    high_water_mark(t) = max(high_water_mark(t-1), equity_curve(t));
    drawdown(t) = (equity_curve(t) / high_water_mark(t)) - 1;
end
maxDrawdown = min(drawdown);


% --- [NEW] Print Detailed Results ---
fprintf('\n--- BACKTEST RESULTS (%.f days) ---\n', numDays);
fprintf('Total Trades: %d\n', numTrades);
if yoloErrors > 0
    fprintf('YOLO Errors: %d\n', yoloErrors);
end

fprintf('\n--- Strategy Performance ---\n');
fprintf('Total Return:     % .2f%%\n', totalReturn_Strategy * 100);
fprintf('Ann. Volatility:  % .2f%%\n', volatility_Strategy * 100);
fprintf('Ann. Sharpe Ratio:% .2f\n', sharpe_Strategy);
fprintf('Max Drawdown:     % .2f%%\n', maxDrawdown * 100);

fprintf('\n--- Buy & Hold Performance ---\n');
fprintf('Total Return:     % .2f%%\n', totalReturn_BH * 100);
fprintf('Ann. Volatility:  % .2f%%\n', volatility_BH * 100);
fprintf('Ann. Sharpe Ratio:% .2f\n', sharpe_BH);
fprintf('--------------------------------------\n');


%% 8. Plot Results
fprintf('Plotting results...\n');
tradingDays = (1:numPoints)';

figure('Name', 'Backtest Results', 'NumberTitle', 'off', 'Units','normalized','Position',[0.1 0.1 0.8 0.8]);

% --- [NEW] Plot 1: Price and Signals (Top Plot) ---
subplot(2, 1, 1);
plot(tradingDays, prices, 'k', 'LineWidth', 1.5);
hold on;
plot(tradingDays, smaFast, 'c-', 'LineWidth', 1);
plot(tradingDays, smaSlow, 'm-', 'LineWidth', 1.5);

% Find buy and sell points
buyPoints = (positions == 1) & (positions_lagged == 0);
sellPoints = (positions == 0) & (positions_lagged == 1);

% Plot buy/sell markers
plot(tradingDays(buyPoints), prices(buyPoints), 'g^', 'MarkerSize', 10, 'MarkerFaceColor', 'g');
plot(tradingDays(sellPoints), prices(sellPoints), 'rv', 'MarkerSize', 10, 'MarkerFaceColor', 'r');

title('Strategy: Price, SMAs, and Trades');
legend('Asset Price', 'SMA Fast', 'SMA Slow', 'Buy Signal', 'Sell Signal', 'Location', 'northwest');
ylabel('Price ($)');
xlabel('Trading Day');
grid on;
ax = gca;
ax.XAxis.Limits = [0 numPoints];


% --- [NEW] Plot 2: Equity Curve (Bottom Plot) ---
subplot(2, 1, 2);
h1 = plot(tradingDays, cumReturns_Strategy * 100, 'b', 'LineWidth', 2);
hold on;
h2 = plot(tradingDays, cumReturns_BH * 100, 'Color', [0.5 0.5 0.5], 'LineWidth', 1.5); % Grey color
title('Strategy Performance: Cumulative Return');
legend([h1, h2], 'SMA Strategy', 'Buy-and-Hold', 'Location', 'northwest');
ylabel('Return (%)');
xlabel('Trading Day');
grid on;
ax = gca;
ax.XAxis.Limits = [0 numPoints];


fprintf('Done.\n');